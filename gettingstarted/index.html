<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · NeXLCore</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
<script src="https://pages.nist.gov/nist-header-footer/js/jquery-1.9.0.min.js" type="text/javascript" defer="defer"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>
</head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="../assets/logo.png" alt="NeXLCore logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>NeXLCore</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Getting-Started-With-NeXLCore"><span>Getting Started With NeXLCore</span></a></li></ul></li><li><a class="tocitem" href="../bremsstrahlung/">Bremsstrahlung</a></li><li><a class="tocitem" href="../Au60Ag40unc/">Mass Fraction Uncertainty</a></li><li><a class="tocitem" href="../eta/">Backscatter</a></li><li><a class="tocitem" href="../fluoryield/">Fluorescence Yield</a></li><li><a class="tocitem" href="../OByStoic/">O by Stoichiometry</a></li><li><a class="tocitem" href="../meanionizationpotential/">Mean Ionization Potential</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/usnistgov/NeXLCore.jl/blob/master/docs/src/gettingstarted.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Getting-Started-With-NeXLCore"><a class="docs-heading-anchor" href="#Getting-Started-With-NeXLCore">Getting Started With NeXLCore</a><a id="Getting-Started-With-NeXLCore-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started-With-NeXLCore" title="Permalink"></a></h2><p><a href="https://github.com/NicholasWMRitchie/NeXLCore.jl">NeXLCore</a> is a Julia language library that provides the core data, algorithms and data structures for the <code>NeXL</code> collection of microanalysis libraries.</p><p>It can be installed from the Julia package repo.</p><pre><code class="nohighlight hljs">using Pkg 
Pkg.add(&quot;NeXLCore&quot;)</code></pre><p>or</p><pre><code class="nohighlight hljs">&gt; ]add NeXLCore</code></pre><p>Primarily <code>NeXLCore</code> provides:</p><ul><li>Definitions of data types relevant to X-ray microanalysis<ul><li><code>Element</code> : Borrowed from the third-party <a href="https://github.com/JuliaPhysics/PeriodicTable.jl"><code>PeriodicTable</code></a> library</li><li><code>Material</code> : Combinations of <code>Element</code>s</li><li><code>SubShell</code> : Representing <code>K</code>, <code>L1</code>, <code>L2</code>, <code>L3</code>, <code>M1</code>,... sub-shells</li><li><code>AtomicSubShell</code> : Representing a <code>SubShell</code> in a specific <code>Element</code></li><li><code>Transition</code> : Representing a non-forbidden X-ray transition between <code>SubShell</code>s - like &quot;K-L3&quot;</li><li><code>CharXRay</code> : Representing a <code>Transition</code> in a specific <code>Element</code></li><li><code>KRatio</code> : A ratio of X-ray intensities</li></ul></li><li>Algorithms to work on these data structures, including (but not limited to)<ul><li><code>energy(xx)</code> where <code>xx</code> may be an <code>AtomicSubShell</code> or a <code>CharXRay</code> (Always in eV!!!)</li><li><code>mac(xx, yy)</code> where <code>xx</code> may be an <code>Element</code> or <code>Material</code> and <code>yy</code> may be a <code>CharXRay</code> or a <code>Float64</code></li></ul></li><li><code>NeXLCore</code> defines two useful macros. Learn them, love them, use them...<ul><li><code>n&quot;???&quot;</code> which creates <code>Element</code>s, <code>SubShell</code>s, <code>AtomicSubShell</code>s, <code>Transition</code>s and <code>CharXRay</code>s from <code>AbstractString</code>s</li><li><code>mat&quot;???&quot;</code> which creates <code>Material</code>s from <code>AbstractString</code>s like <code>mat&quot;AlNaSi3O8&quot;</code></li></ul></li><li>Throughout <code>NeXL</code>, units are always electron-volt (energy), centimeter (length), second (time), gram (mass) and angles are in radians even when it seems a little odd.<ul><li>A foolish consistency? I think not...</li></ul></li><li><code>NeXL</code> uses <a href="https://github.com/GiovineItalia/Gadfly.jl">Gadfly</a> for plotting.<ul><li>Many things you&#39;d want to plot can be plotted using <code>using Gadfly; plot(x)</code></li><li>However, to minimize overhead, plotting support is not loaded (thanks to <a href="https://github.com/JuliaPackaging/Requires.jl">Requires</a>) until Gadfly is explicitly loaded by the user.</li><li>Plots can be readily embedded into Jupyter notebooks and Weave documents.</li></ul></li><li><code>NeXL</code> uses <a href="https://github.com/JuliaData/DataFrames.jl">DataFrames</a> for tabular data.</li></ul><p><strong>Let&#39;s get this party started...</strong></p><p>Load the library</p><pre><code class="language-julia hljs">using NeXLCore</code></pre><h4 id="Element"><a class="docs-heading-anchor" href="#Element">Element</a><a id="Element-1"></a><a class="docs-heading-anchor-permalink" href="#Element" title="Permalink"></a></h4><p>Constructing <code>Element</code> objects</p><pre><code class="language-julia hljs">julia&gt; e1, e2, e3 = n&quot;Ca&quot;, elements[20], parse(Element, &quot;Pu&quot;)
(Element(Calcium), Element(Calcium), Element(Plutonium))

julia&gt; es = [ n&quot;Ca&quot;, n&quot;21&quot;, n&quot;Ti&quot;, n&quot;Vanadium&quot; ]
4-element Vector{Element}:
 Element(Calcium)
 Element(Scandium)
 Element(Titanium)
 Element(Vanadium)</code></pre><p>Note the use of <code>n&quot;??&quot;</code>.  We&#39;ll see a lot of this.</p><p>Elements come with lots of useful information...</p><pre><code class="language-julia hljs">julia&gt; e3
Plutonium (Pu), number 94:
        category: actinide
     atomic mass: 244.0 u
         density: 19.816 g/cm³
      molar heat: 35.5 J/mol⋅K
   melting point: 912.5 K
   boiling point: 3505.0 K
           phase: Solid
          shells: [2, 8, 18, 32, 24, 8, 2]
e⁻-configuration: 1s² 2s² 2p⁶ 3s² 3p⁶ 4s² 3d¹⁰ 4p⁶ 5s² 4d¹⁰ 5p⁶ 6s² 4f¹⁴ 5d¹⁰ 6p⁶ 7s² 5f⁶
      appearance: silvery white, tarnishing to dark gray in air
         summary: Plutonium is a transuranic radioactive chemical element with symbol Pu and atomic number 94. It is an actinide metal of silvery-gray appearance that tarnishes when exposed to air, and forms a dull coating when oxidized. The element normally exhibits six allotropes and four oxidation states.
   discovered by: Glenn T. Seaborg
          source: https://en.wikipedia.org/wiki/Plutonium
</code></pre><p>To help you to iterate over all elements for which there is a complete set of atomic and X-ray data there is the function</p><pre><code class="language-julia hljs">julia&gt; eachelement()
(Element(Hydrogen), Element(Helium), Element(Lithium), Element(Beryllium), Element(Boron), Element(Carbon), Element(Nitrogen), Element(Oxygen), Element(Fluorine), Element(Neon), Element(Sodium), Element(Magnesium), Element(Aluminium), Element(Silicon), Element(Phosphorus), Element(Sulfur), Element(Chlorine), Element(Argon), Element(Potassium), Element(Calcium), Element(Scandium), Element(Titanium), Element(Vanadium), Element(Chromium), Element(Manganese), Element(Iron), Element(Cobalt), Element(Nickel), Element(Copper), Element(Zinc), Element(Gallium), Element(Germanium), Element(Arsenic), Element(Selenium), Element(Bromine), Element(Krypton), Element(Rubidium), Element(Strontium), Element(Yttrium), Element(Zirconium), Element(Niobium), Element(Molybdenum), Element(Technetium), Element(Ruthenium), Element(Rhodium), Element(Palladium), Element(Silver), Element(Cadmium), Element(Indium), Element(Tin), Element(Antimony), Element(Tellurium), Element(Iodine), Element(Xenon), Element(Cesium), Element(Barium), Element(Lanthanum), Element(Cerium), Element(Praseodymium), Element(Neodymium), Element(Promethium), Element(Samarium), Element(Europium), Element(Gadolinium), Element(Terbium), Element(Dysprosium), Element(Holmium), Element(Erbium), Element(Thulium), Element(Ytterbium), Element(Lutetium), Element(Hafnium), Element(Tantalum), Element(Tungsten), Element(Rhenium), Element(Osmium), Element(Iridium), Element(Platinum), Element(Gold), Element(Mercury), Element(Thallium), Element(Lead), Element(Bismuth), Element(Polonium), Element(Astatine), Element(Radon), Element(Francium), Element(Radium), Element(Actinium), Element(Thorium), Element(Protactinium), Element(Uranium))</code></pre><p>As you can see, each element comes with many different properties which can be accessed by the field names. <code>PeriodicTable</code> uses <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful</code></a> to provide physical units for quantities.</p><pre><code class="language-julia hljs">julia&gt; fieldnames(Element)
(:name, :appearance, :atomic_mass, :boil, :category, :color, :cpk_hex, :density, :discovered_by, :el_config, :melt, :molar_heat, :named_by, :number, :period, :phase, :source, :spectral_img, :summary, :symbol, :xpos, :ypos, :shells)

julia&gt; e1.name, name(e1)
(&quot;Calcium&quot;, &quot;Calcium&quot;)

julia&gt; e1.symbol, symbol(e1)
(&quot;Ca&quot;, &quot;Ca&quot;)

julia&gt; e1.atomic_mass, a(e1)
(40.0784 u, 40.0784)

julia&gt; e1.number, z(e1)
(20, 20)

julia&gt; e1.boil
1757.0 K

julia&gt; e1.density, density(e1)
(1.55 g cm^-3, 1.55)

julia&gt; e1.el_config
&quot;1s² 2s² 2p⁶ 3s² 3p⁶ 4s²&quot;</code></pre><h4 id="Material"><a class="docs-heading-anchor" href="#Material">Material</a><a id="Material-1"></a><a class="docs-heading-anchor-permalink" href="#Material" title="Permalink"></a></h4><p>The <code>Material</code> structure carries composition information as mass fractions of the elements. This object also carries name, atomic weight, and other properties like density.  A simple way to create <code>Material</code> objects is the <code>mat&quot;??&quot;</code> macro. To get the mass fraction&#39;s out index the object with an element.  All the <code>Element</code>s in a <code>Material</code> are accessed via <code>keys(...)</code>.</p><pre><code class="language-julia hljs">julia&gt; albite = mat&quot;AlNaSi3O8&quot;
AlNaSi3O8[Al=0.1029,Na=0.0877,Si=0.3213,O=0.4881]

julia&gt; albite[n&quot;Al&quot;], albite[n&quot;Na&quot;], albite[n&quot;Tc&quot;]
(0.10289723395373596, 0.08767415772881798, 0.0)

julia&gt; keys(albite) # keys(...) for consistency with other Julia objects
KeySet for a Dict{Element, Float64} with 4 entries. Keys:
  Element(Aluminium)
  Element(Sodium)
  Element(Silicon)
  Element(Oxygen)

julia&gt; collect(keys(albite)) # Now maybe this is a little more clear
4-element Vector{Element}:
 Element(Aluminium)
 Element(Sodium)
 Element(Silicon)
 Element(Oxygen)

julia&gt; a(n&quot;Na&quot;, albite)
22.989769282</code></pre><p>You can enter mass fractions in directly using the <code>mat&quot;??&quot;</code> syntax.</p><pre><code class="language-julia hljs">julia&gt; mat = mat&quot;0.8*Fe+0.15*Ni+0.05*Cr&quot;
0.8⋅Fe+0.15⋅Ni+0.05⋅Cr[Fe=0.8000,Cr=0.0500,Ni=0.1500]</code></pre><p>There are more sophisticated ways to create materials with additional properties.  For example, I could have created a richer definition of albite.</p><pre><code class="language-julia hljs">julia&gt; albite = parse(Material, &quot;AlNaSi3O8&quot;, name=&quot;Albite&quot;, density=2.60, atomicweights=Dict(n&quot;Na&quot;=&gt;23.0))
Albite[Al=0.1029,Na=0.0877,Si=0.3213,O=0.4881,2.60 g/cm³]

julia&gt; all(e-&gt;a(e)==a(e,albite), keys(albite)) # Not all are default
false

julia&gt; a(n&quot;Na&quot;, albite),  a(n&quot;O&quot;, albite)
(23.0, 15.999)

julia&gt; ss = parse(Material, &quot;0.8*Fe+0.15*Ni+0.05*Cr&quot;, name=&quot;Stainless&quot;, density=7.5)
Stainless[Fe=0.8000,Cr=0.0500,Ni=0.1500,7.50 g/cm³]

julia&gt; ss[n&quot;Fe&quot;], density(ss), name(ss)
(0.8, 7.5, &quot;Stainless&quot;)

julia&gt; all(e-&gt;a(e)==a(e,ss), keys(ss)) # The atomic weights are the default values (from PeriodicTable)
true</code></pre><p>Alternatively, I could have built albite in terms of atom fractions.  Note that the mass fractions are different because the assumed atomic weight of sodium is different.</p><pre><code class="language-julia hljs">julia&gt; albite2 = atomicfraction(&quot;Albite&quot;, n&quot;Al&quot;=&gt;1, n&quot;Na&quot;=&gt;1, n&quot;Si&quot;=&gt;3, n&quot;O&quot;=&gt;8, properties=Dict{Symbol,Any}(:Density=&gt;2.6), atomicweights=Dict(n&quot;Na&quot;=&gt;22.0))
Albite[Al=0.1033,Na=0.0842,Si=0.3225,O=0.4900,2.60 g/cm³]</code></pre><pre><code class="language-julia hljs">julia&gt; using DataFrames

julia&gt; asa(DataFrame, albite2)
4×7 DataFrame
 Row │ Material  Element  Z      A        C(z)       Norm[C(z)]  A(z)
     │ String    String   Int64  Float64  Float64    Float64     Float64
─────┼─────────────────────────────────────────────────────────────────────
   1 │ Albite    O            8  15.999   0.489962    0.489962   0.615385
   2 │ Albite    Na          11  22.0     0.0842174   0.0842174  0.0769231
   3 │ Albite    Al          13  26.9815  0.103287    0.103287   0.0769231
   4 │ Albite    Si          14  28.085   0.322534    0.322534   0.230769</code></pre><p>There are many methods for transforming representation of the composition.</p><pre><code class="language-julia hljs">julia&gt; ss = parse(Material,&quot;0.78*Fe+0.15*Ni+0.04*Cr&quot;,name=&quot;Stainless&quot;)
Stainless[Fe=0.7800,Cr=0.0400,Ni=0.1500]

julia&gt; analyticaltotal(ss)
0.9700000000000001

julia&gt; atomicfraction(ss)
Dict{Element, AbstractFloat} with 3 entries:
  Element(Iron)     =&gt; 0.807719
  Element(Chromium) =&gt; 0.0444878
  Element(Nickel)   =&gt; 0.147793

julia&gt; normalizedmassfraction(ss)
Dict{Element, AbstractFloat} with 3 entries:
  Element(Iron)     =&gt; 0.804124
  Element(Chromium) =&gt; 0.0412371
  Element(Nickel)   =&gt; 0.154639

julia&gt; asnormalized(ss)
N[Stainless,1.0][Fe=0.8041,Cr=0.0412,Ni=0.1546]</code></pre><pre><code class="language-julia hljs">julia&gt; compare(ss, asnormalized(ss))
3×11 DataFrame
 Row │ Material 1  Material 2        Elm     C₁(z)      C₂(z)    ΔC          ΔC/C     A₁(z)      A₂(z)      ΔA           ΔA/A
     │ String      String            String  Float64    Float64  Float64     Float64  Float64    Float64    Float64      Float64
─────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │ Stainless   N[Stainless,1.0]  Fe      0.804124      0.78  0.0241237      0.03  0.807719   0.807719   0.0          0.0
   2 │ Stainless   N[Stainless,1.0]  Cr      0.0412371     0.04  0.00123711     0.03  0.0444878  0.0444878  6.93889e-18  1.55973e-16
   3 │ Stainless   N[Stainless,1.0]  Ni      0.154639      0.15  0.00463918     0.03  0.147793   0.147793   2.77556e-17  1.87801e-16</code></pre><p>It is also possible to define materials using <code>NeXLUncertainties.UncertainValue</code>s.  However, it is better to use the full uncertainty calculation to perform transforms since this handles correlated quantities correctly.</p><pre><code class="language-julia hljs">julia&gt; ss=material(&quot;Stainless&quot;,n&quot;Fe&quot;=&gt;uv(0.79,0.01),n&quot;Ni&quot;=&gt;uv(0.15,0.003),n&quot;Cr&quot;=&gt;uv(0.04,0.002))
Stainless[Fe=0.7900,Cr=0.0400,Ni=0.1500]

julia&gt; ss[n&quot;Fe&quot;]
0.790 ± 0.010

julia&gt; atomicfraction(ss)[n&quot;Fe&quot;]
0.810 ± 0.010</code></pre><h4 id="SubShell"><a class="docs-heading-anchor" href="#SubShell">SubShell</a><a id="SubShell-1"></a><a class="docs-heading-anchor-permalink" href="#SubShell" title="Permalink"></a></h4><p><code>SubShell</code> objects are not often used directly but are occasionally returned by other methods so I&#39;ll just mention them in passing.  <code>SubShell</code> represent the notion of a sub-shell independent of which element it is associated with.  There are properties of sub-shells that don&#39;t depend on the element like the angular momentum quantum numbers.</p><pre><code class="language-julia hljs">julia&gt; ss = n&quot;L3&quot;
L3

julia&gt; shell(ss) # Shells are identified by a Char
L

julia&gt; NeXLCore.n(ss), NeXLCore.l(ss), NeXLCore.j(ss)
(2, 1, 3//2)

julia&gt; allsubshells
39-element Vector{SubShell}:
 K
 L1
 L2
 L3
 M1
 M2
 M3
 M4
 M5
 N1
 ⋮
 P6
 P7
 P8
 P9
 P10
 P11
 Q1
 Q2
 Q3

julia&gt; ksubshells, lsubshells, msubshells, nsubshells
((K,), (L1, L2, L3), (M1, M2, M3, M4, M5), (N1, N2, N3, N4, N5, N6, N7))</code></pre><p>There is one gotcha with <code>SubShell</code>s and the <code>n&quot;??&quot;</code> notation.  What is <code>n&quot;K&quot;</code>? Potassium or the K-subshell?  The answer for <code>NeXL</code> is potassium.  The K-subshell is <code>n&quot;K1&quot;</code> like the first L-subshell is <code>n&quot;L1&quot;</code>.  (This is rarely ever an issue)</p><pre><code class="language-julia hljs">julia&gt; n&quot;K1&quot;, n&quot;K&quot;
(K, Element(Potassium))</code></pre><h4 id="AtomicSubShell"><a class="docs-heading-anchor" href="#AtomicSubShell">AtomicSubShell</a><a id="AtomicSubShell-1"></a><a class="docs-heading-anchor-permalink" href="#AtomicSubShell" title="Permalink"></a></h4><p><code>AtomicSubShell</code> joins an <code>Element</code> to a <code>SubShell</code>.  You&#39;ll only be permitted to create <code>AtomicSubShell</code> objects for sub-shells which exist for the ground state of the element. (X-ray microanalysis only deals with ground state atoms.  Astronomers and plasma physicists not so much...)</p><pre><code class="language-julia hljs">julia&gt; ass = n&quot;Fe L3&quot;
Fe L3

julia&gt; shell(ass), ass.subshell
(L, L3)

julia&gt; jumpratio(ass)
6.3305

julia&gt; has(n&quot;C&quot;,n&quot;L3&quot;), has(n&quot;C&quot;,n&quot;L2&quot;)  # Carbon Kα1 is K-L2!!!
(false, true)

julia&gt; n&quot;C L2&quot; # works while n&quot;C L3&quot; throws an exception
C L2

julia&gt; energy(ass), energy(n&quot;Ca K&quot;)
(708.0999999999999, 4038.1)

julia&gt; kk=n&quot;K K&quot;
K K

julia&gt; element(kk), shell(kk), kk.subshell # This works as you&#39;d expect. (Relevant to the earlier gotcha notice...)
(Element(Potassium), K, K)</code></pre><h4 id="Transition"><a class="docs-heading-anchor" href="#Transition">Transition</a><a id="Transition-1"></a><a class="docs-heading-anchor-permalink" href="#Transition" title="Permalink"></a></h4><p>Transitions are the analog to <code>SubShell</code>.  They represent the non-element related information associated with optical (in the broad sense) transitions.  You can only create <code>Transition</code>s for transitions with a non-negligible transition rate in some element.</p><pre><code class="language-julia hljs">julia&gt; trs = n&quot;K-L3&quot;, n&quot;L3-M5&quot;, n&quot;M5-N7&quot;
(K-L3, L3-M5, M5-N7)

julia&gt; alltransitions
(K-L2, K-L3, K-M2, K-M3, K-M4, K-M5, K-N2, K-N3, K-N4, K-N5, K-O2, K-O3, K-O4, K-O5, K-P2, L1-M2, L1-M3, L1-M4, L1-M5, L1-N2, L1-N3, L1-N4, L1-N5, L1-O2, L1-O3, L1-O4, L1-O5, L1-P2, L2-M1, L2-M3, L2-M4, L2-N1, L2-N3, L2-N4, L2-N6, L2-O1, L2-O3, L2-O4, L2-O6, L2-P1, L3-M1, L3-M2, L3-M3, L3-M4, L3-M5, L3-N1, L3-N2, L3-N3, L3-N4, L3-N5, L3-N6, L3-N7, L3-O1, L3-O2, L3-O3, L3-O4, L3-O5, L3-O6, L3-O7, L3-P1, L3-P2, M1-N2, M1-N3, M1-O2, M1-O3, M1-P2, M2-N1, M2-N4, M2-O1, M2-O4, M2-P1, M3-N1, M3-N4, M3-N5, M3-O1, M3-O4, M3-O5, M3-P1, M4-N2, M4-N3, M4-N6, M4-O2, M4-O3, M4-O6, M4-P2, M5-N3, M5-N6, M5-N7, M5-O3, M5-O6, M5-O7)

julia&gt; ktransitions
(K-L2, K-L3, K-M2, K-M3, K-M4, K-M5, K-N2, K-N3, K-N4, K-N5, K-O2, K-O3, K-O4, K-O5, K-P2)

julia&gt; kalpha, kbeta, kother
((K-L2, K-L3), (K-M2, K-M3, K-M4, K-M5), (K-M2, K-M3, K-M4, K-M5, K-N2, K-N3, K-N4, K-N5, K-O2, K-O3, K-O4, K-O5, K-P2))

julia&gt; ltransitions
(L1-M2, L1-M3, L1-M4, L1-M5, L1-N2, L1-N3, L1-N4, L1-N5, L1-O2, L1-O3, L1-O4, L1-O5, L1-P2, L2-M1, L2-M3, L2-M4, L2-N1, L2-N3, L2-N4, L2-N6, L2-O1, L2-O3, L2-O4, L2-O6, L2-P1, L3-M1, L3-M2, L3-M3, L3-M4, L3-M5, L3-N1, L3-N2, L3-N3, L3-N4, L3-N5, L3-N6, L3-N7, L3-O1, L3-O2, L3-O3, L3-O4, L3-O5, L3-O6, L3-O7, L3-P1, L3-P2)

julia&gt; mtransitions
(M1-N2, M1-N3, M1-O2, M1-O3, M1-P2, M2-N1, M2-N4, M2-O1, M2-O4, M2-P1, M3-N1, M3-N4, M3-N5, M3-O1, M3-O4, M3-O5, M3-P1, M4-N2, M4-N3, M4-N6, M4-O2, M4-O3, M4-O6, M4-P2, M5-N3, M5-N6, M5-N7, M5-O3, M5-O6, M5-O7)

julia&gt; shell.( trs )
(K, L, M)

julia&gt; inner.( trs )
(K, L3, M5)

julia&gt; outer.( trs )
(L3, M5, N7)</code></pre><p>The lists of transitions will suddenly seem useful in just a minute...</p><h4 id="CharXRay"><a class="docs-heading-anchor" href="#CharXRay">CharXRay</a><a id="CharXRay-1"></a><a class="docs-heading-anchor-permalink" href="#CharXRay" title="Permalink"></a></h4><p>Finally! What we came here for... <code>CharXRay</code> represent a specific <code>Transition</code> in a specific <code>Element</code>.  Again you can only create <code>CharXRay</code> objects for characteristic X-rays with non-negligible transition rates. (i.e. Ones that you might see in a X-ray spectrum or wavescan.)</p><p>First, let&#39;s create some characteristic X-rays using <code>n&quot;??&quot;</code> notation or <code>characteristic(...)</code></p><pre><code class="language-julia hljs">julia&gt; feka1, fela = n&quot;Fe K-L3&quot;, n&quot;Fe L3-M5&quot;
(Fe K-L3, Fe L3-M5)

julia&gt; feka = characteristic(n&quot;Fe&quot;,kalpha) # Filters kalpha to produce only those CharXRay that exist for Fe
2-element Vector{CharXRay}:
 Fe K-L2
 Fe K-L3

julia&gt; fekb = characteristic(n&quot;Fe&quot;,kbeta)
4-element Vector{CharXRay}:
 Fe K-M2
 Fe K-M3
 Fe K-M4
 Fe K-M5</code></pre><p>Some properties of characteristic X-rays:</p><pre><code class="language-julia hljs">julia&gt; inner.(feka)
2-element Vector{AtomicSubShell}:
 Fe K
 Fe K

julia&gt; outer.(feka)
2-element Vector{AtomicSubShell}:
 Fe L2
 Fe L3

julia&gt; transition.(feka)
2-element Vector{Transition}:
 K-L2
 K-L3

julia&gt; all(s-&gt;s==Shell(1), shell.(feka))
true

julia&gt; all(e-&gt;e==n&quot;Fe&quot;, element.(feka))
true</code></pre><p>Let&#39;s extract some energy-related properties from these objects.  Of course, it is in eV.</p><pre><code class="language-julia hljs">julia&gt; energy.(feka) # The x-ray energy
2-element Vector{Float64}:
 6390.9
 6403.9

julia&gt; edgeenergy.(feka) # ionization edge energy
2-element Vector{Float64}:
 7112.0
 7112.0</code></pre><p>Often we want to know the relative line-weights of the transitions.</p><pre><code class="language-julia hljs">julia&gt; weight.(NormalizeByShell, characteristic(n&quot;Fe&quot;, ltransitions)) # sum(...)=1
14-element Vector{Float64}:
 0.04304167415466284
 0.06389899746585781
 0.0001306859940597016
 0.0001774748067477429
 0.08193870819313345
 0.0013040610916394452
 0.19915910782871307
 0.011753596374972516
 0.1588979621813908
 0.0013520694901178318
 0.0013165665713401205
 0.034020671918741675
 0.3802392186858509
 0.022769205242772064

julia&gt; weight.(NormalizeBySubShell, characteristic(n&quot;Fe&quot;, ltransitions)) # sum(...)=3
14-element Vector{Float64}:
 0.4013253401731517
 0.5958013343663264
 0.001218530692682046
 0.0016547947678398158
 0.2785557828362096
 0.0044332375535096466
 0.6770538908110011
 0.039957088799279755
 0.26545122818314754
 0.002258735743451679
 0.0021994253957024006
 0.05683414073074585
 0.6352187669237488
 0.03803770302320376

julia&gt; brightest(characteristic(n&quot;Fe&quot;, ltransitions))
Fe L3-M5</code></pre><p>Some other X-ray related properties...</p><pre><code class="language-julia hljs">julia&gt; λ.(feka)  # this is \lambda (wavelength in cm)
2-element Vector{Float64}:
 1.940011554447735e-8
 1.9360733058480036e-8

julia&gt; ν.(feka)  # this is \nu (frequency in 1/s)
2-element Vector{Float64}:
 1.5453127447240502e18
 1.5484561307387604e18

julia&gt; ω.(feka)  # this is \omega (angular frequency in radian/s)
2-element Vector{Float64}:
 9.70948633264751e18
 9.729236809469932e18

julia&gt; wavenumber.(feka) # In 1/cm
2-element Vector{Float64}:
 5.154608474920506e7
 5.16509368203906e7</code></pre><p>Finally, mass absorption coefficients.  MACs quantify the degree to which X-rays are absorbed as they travel through material. MACs are available for <code>Element</code> or for <code>Material</code>.  Here we are accepting the default (<a href="https://www.nist.gov/pml/x-ray-form-factor-attenuation-and-scattering-tables">FFAST</a>) algorithm for the MACs except in the last line.</p><pre><code class="language-julia hljs">julia&gt; mac( n&quot;Ni&quot;, n&quot;Fe K-L3&quot;) # In cm²/g
83.48344476953369

julia&gt; Dict(map(cxr-&gt;(cxr=&gt;( mac(n&quot;Ni&quot;,cxr), weight(NormalizeToUnity, cxr))), characteristic(n&quot;Ni&quot;, ltransitions)))
Dict{CharXRay, Tuple{Float64, Float64}} with 14 entries:
  Ni L1-M5 =&gt; (9496.52, 0.000291368)
  Ni L2-M1 =&gt; (2149.34, 0.0870678)
  Ni L3-M2 =&gt; (1999.76, 0.00246174)
  Ni L2-M3 =&gt; (1910.69, 0.00233065)
  Ni L2-M4 =&gt; (9677.04, 0.522291)
  Ni L1-M2 =&gt; (11241.6, 0.0618071)
  Ni L2-N1 =&gt; (9643.95, 0.0181068)
  Ni L3-M1 =&gt; (2255.04, 0.170298)
  Ni L3-M3 =&gt; (1999.76, 0.0023918)
  Ni L3-M4 =&gt; (1693.36, 0.0918605)
  Ni L3-N1 =&gt; (1688.47, 0.0342265)
  Ni L1-M3 =&gt; (11241.6, 0.0946162)
  Ni L1-M4 =&gt; (9496.52, 0.000221948)
  Ni L3-M5 =&gt; (1693.36, 1.0)

julia&gt; mac( mat&quot;0.8*Fe+0.15*Ni+0.05*Cr&quot;, n&quot;C K-L2&quot;) # Carbon K-L3 in stainless steel (interpreted as mass fractions of elements)
12220.92856189755

julia&gt; mac( mat&quot;AlNaSi3O8&quot;, n&quot;O K-L3&quot;) # O K-L3 in Albite (interpreted as a chemical formular)
3834.2955800593218

julia&gt; mac( mat&quot;AlNaSi3O8&quot;, n&quot;O K-L3&quot;, NeXLCore.FFASTDB), mac( mat&quot;AlNaSi3O8&quot;, n&quot;O K-L3&quot;, NeXLCore.DTSA) # Compare and contrast...
(3834.2955800593218, 4111.003591230517)</code></pre><h4 id="KRatio"><a class="docs-heading-anchor" href="#KRatio">KRatio</a><a id="KRatio-1"></a><a class="docs-heading-anchor-permalink" href="#KRatio" title="Permalink"></a></h4><p>k-ratios are the core quantity for X-ray microanalysis.  We measure intensities but k-ratios make the intensities meaningful.</p><pre><code class="language-julia hljs">julia&gt; kr = KRatio(
             [n&quot;Fe K-L3&quot;, n&quot;Fe K-L2&quot; ],
             Dict(:BeamEnergy=&gt;20.0e3, :TakeOffAngle=&gt;deg2rad(40.0)), # Unknown properties
             Dict(:BeamEnergy=&gt;20.0e3, :TakeOffAngle=&gt;deg2rad(40.0)), # Standard properties
             mat&quot;Fe2O3&quot;, # Standard composition
             uv(0.343563,0.0123105)) # The k-ratio value
k[Fe K-L3 + 1 other, Fe2O3] = 0.344 ± 0.012</code></pre><p>Combine k-ratios together in <code>Vector</code>.</p><pre><code class="language-julia hljs">julia&gt; props =  ( Dict(:BeamEnergy=&gt;20.0e3, :TakeOffAngle=&gt;deg2rad(40.0)),
                  Dict(:BeamEnergy=&gt;20.0e3, :TakeOffAngle=&gt;deg2rad(40.0)))
(Dict(:BeamEnergy =&gt; 20000.0, :TakeOffAngle =&gt; 0.6981317007977318), Dict(:BeamEnergy =&gt; 20000.0, :TakeOffAngle =&gt; 0.6981317007977318))

julia&gt; krs = [
         KRatio(characteristic(n&quot;O&quot;, ktransitions), props..., mat&quot;SiO2&quot;, uv(0.984390, 0.00233)),
         KRatio(characteristic(n&quot;Na&quot;, ktransitions), props..., mat&quot;NaCl&quot;, uv(0.155406, 0.00093)),
         KRatio(characteristic(n&quot;Al&quot;, ktransitions), props..., mat&quot;Al&quot;, uv(0.068536, 0.000733)),
         KRatio(characteristic(n&quot;Si&quot;, ktransitions), props..., mat&quot;Si&quot;, uv(0.219054, 0.00023)),
         KRatio(characteristic(n&quot;Th&quot;, mtransitions), props..., mat&quot;Th&quot;, uv(-0.00023, 0.00046)),
       ]
5-element Vector{KRatio}:
 k[O K-L3 + 1 other, SiO2] = 0.9844 ± 0.0023
 k[Na K-L3 + 1 other, NaCl] = 0.1554 ± 0.0009
 k[Al K-L3 + 2 others, Al] = 0.0685 ± 0.0007
 k[Si K-L3 + 2 others, Si] = 0.2190 ± 0.0002
 k[Th M5-N7 + 26 others, Th] = -0.0002 ± 0.0005</code></pre><pre><code class="language-julia hljs">julia&gt; nonnegk.(krs)
5-element Vector{UncertainValue}:
 0.9844 ± 0.0023
 0.1554 ± 0.0009
 0.0685 ± 0.0007
 0.2191 ± 0.0002
 0.0000 ± 0.0005

julia&gt; elms(krs)
Set{Element} with 5 elements:
  Element(Aluminium)
  Element(Sodium)
  Element(Thorium)
  Element(Oxygen)
  Element(Silicon)</code></pre><p><code>KRatio</code> objects match well with individual spectra or individual point acqusitions in WDS.  For hyper-spectra, them <code>KRatios</code> object type might be more appropriate.  <code>KRatios</code> assumes that all the properties are in common for all the entries in the object so it maintains only one copy.</p><h4 id="Monte-Carlo"><a class="docs-heading-anchor" href="#Monte-Carlo">Monte Carlo</a><a id="Monte-Carlo-1"></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo" title="Permalink"></a></h4><p>NeXLCore also includes a rudimentary Monte Carlo simulator of electron trajectories.  While it is currently limited to modeling element trajectories, it can be extended to handle quite complex sample geometries because it is based on  the <code>GeometryBasics</code> package that defines both simple and meshed shapes.  Currently, basic blocks and spheres have been implemented.</p><pre><code class="language-julia hljs">julia&gt; # Build a alumina coated silica particle on a carbon substrate
       mat = material(&quot;SiO2&quot;,2.648)
SiO2[Si=0.4674,O=0.5326,2.65 g/cm³]

julia&gt; sample = coated_particle(mat, 1.0e-4, material(&quot;Al2O3&quot;, 3.99), 0.1e-4, material(&quot;C&quot;,2.0))
Region[Chamber, GeometryBasics.Rect3D{Float64}([-100.0, -100.0, -100.0], [200.0, 200.0, 200.0]), H[H=1.0000,0.00 g/cm³], 2 children]</code></pre><p>Now let&#39;s run a MC simulation to compute the path length of an electron in a material.</p><pre><code class="language-julia hljs">using Gadfly # for plot(...)

# Each call to the trajectory function runs a single electron trajecory while calling the `do`
# clause at each elastic scatter point.  The arguments to the do clause are a representation
# of the electron and the Region in which the last step occured.
function mc_path_length(e0, mat)
  len=0.0
  trajectory(gun(Electron, e0, 1.0e-6), bulk(mat)) do electron, region
    len += region.material == mat ? NeXLCore.pathlength(electron) : 0.0
  end
  return len
end
# Let&#39;s look at the path-length as a function of incident energy.
# The downward spikes are ???                (Backscattered e⁻)
plot(e0-&gt;mc_path_length(e0,mat), 1.0e3, 20.0e3)</code></pre><p><img src="../figures/gettingstarted_28_1.svg" alt/></p><p>Or a second example...</p><pre><code class="language-julia hljs"># Let&#39;s look at the number of scatter events as a function of incident energy.
function mc_n_scatters(e0, mat)
  cx=0
  trajectory(gun(Electron, e0, 1.0e-6), bulk(mat)) do electron, region
    cx += 1
  end
  return cx
end

plot(e0-&gt;mc_n_scatters(e0, mat), 1.0e3, 20.0e3)</code></pre><p><img src="../figures/gettingstarted_29_1.svg" alt/></p><p>There is more but this should get you started.  As always, the code is the ultimate resource and you have it in your hands.  Please report any bugs you find at <a href="https://github.com/NicholasWMRitchie/NeXLCore.jl">NeXLCore</a>.</p><h4 id="Appendix:-Plotting-with-Gadfly"><a class="docs-heading-anchor" href="#Appendix:-Plotting-with-Gadfly">Appendix: Plotting with Gadfly</a><a id="Appendix:-Plotting-with-Gadfly-1"></a><a class="docs-heading-anchor-permalink" href="#Appendix:-Plotting-with-Gadfly" title="Permalink"></a></h4><p>There are a number of helpful plotting methods to take an overhead look at various NeXLCore attributes.</p><p>Plot the X-ray energy for all transitions in all elements</p><pre><code class="language-julia hljs">using Gadfly
display(plot(collect(ktransitions), mode = :Energy))
display(plot(collect(ltransitions), mode = :Energy))
display(plot(collect(mtransitions), mode = :Energy))</code></pre><p><img src="../figures/gettingstarted_30_1.svg" alt/> <img src="../figures/gettingstarted_30_2.svg" alt/> <img src="../figures/gettingstarted_30_3.svg" alt/></p><p>Plot the X-ray line weight for all transitions</p><pre><code class="language-julia hljs">display(plot(collect(ktransitions), mode = :Weight))
display(plot(collect(ltransitions), mode = :Weight))
display(plot(collect(mtransitions), mode = :Weight))</code></pre><p><img src="../figures/gettingstarted_31_1.svg" alt/> <img src="../figures/gettingstarted_31_2.svg" alt/> <img src="../figures/gettingstarted_31_3.svg" alt/></p><p>Plot the edge energy for all subshells in all elements.</p><pre><code class="language-julia hljs">display(plot(collect(ksubshells), :EdgeEnergy))
display(plot(collect(lsubshells), :EdgeEnergy))
display(plot(collect(msubshells), :EdgeEnergy))</code></pre><p><img src="../figures/gettingstarted_32_1.svg" alt/> <img src="../figures/gettingstarted_32_2.svg" alt/> <img src="../figures/gettingstarted_32_3.svg" alt/></p><p>Plot the fluorescence yield for all subshells in all elements.</p><pre><code class="language-julia hljs">display(plot(collect(ksubshells), :FluorescenceYield))
display(plot(collect(lsubshells), :FluorescenceYield))
display(plot(collect(msubshells), :FluorescenceYield))</code></pre><p><img src="../figures/gettingstarted_33_1.svg" alt/> <img src="../figures/gettingstarted_33_2.svg" alt/> <img src="../figures/gettingstarted_33_3.svg" alt/></p><p>Finally, to compare MAC algorithms...</p><pre><code class="language-julia hljs">display(NeXLCore.compareMACs(n&quot;C&quot;))
display(NeXLCore.compareMACs(n&quot;U&quot;))</code></pre><p><img src="../figures/gettingstarted_34_1.svg" alt/> <img src="../figures/gettingstarted_34_2.svg" alt/></p><p>Or MAC algorithms one at a time...</p><pre><code class="language-julia hljs">display(plot(NeXLCore.FFASTDB, n&quot;Ag&quot;))
display(plot(NeXLCore.DTSA, n&quot;Au&quot;))</code></pre><p><img src="../figures/gettingstarted_35_1.svg" alt/> <img src="../figures/gettingstarted_35_2.svg" alt/></p><p>Or many elements at once...</p><pre><code class="language-julia hljs">plot(NeXLCore.FFASTDB, collect(keys(albite)),xmax=5.0e3)</code></pre><p><img src="../figures/gettingstarted_36_1.svg" alt/></p><p>Or a Material MAC...</p><pre><code class="language-julia hljs">plot(NeXLCore.FFASTDB, [keys(albite)..., albite], xmax=5.0e3)</code></pre><p><img src="../figures/gettingstarted_37_1.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="../bremsstrahlung/">Bremsstrahlung »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 30 December 2021 12:59">Thursday 30 December 2021</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
